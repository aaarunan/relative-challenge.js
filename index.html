<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Relative challenge</title>
    <style>
      body {
        margin: 0;
        background: #111;
        color: #fff;
        font-family: sans-serif;
      }
      canvas {
        display: block;
        margin: auto;
        background: #222;
      }
      #score {
        text-align: center;
        margin-top: 10px;
        font-size: 20px;
      }
    </style>
  </head>
  <body>
    <canvas id="game" width="400" height="600"></canvas>
    <div id="statuses" style="text-align: center; margin-top: 10px">
      <div id="score">Score: 0</div>

      <div id="difficulty">Difficulty: 1</div>
      <div id="hitAccuracy">Hit Accuracy: 100%</div>

      <div id="missRate">Miss Rate: 0%</div>
      <div id="unstableRate">Unstable Rate: 0</div>
      <div id="comboLength">Max Combo: 0</div>
      <div id="avgResult">Average Result: 0</div>
      <div id="hitLog">Hit Log:</div>
      <div id="gameEnded">False</div>
    </div>
    <div id="actionPanel">
      <button id="startButton" style="margin-top: 10px">Start Game</button>
      <button id="stopButton" style="margin-top: 10px">Stop Game</button>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      const beatMap = {
        bpm: 120,
        duration: 6, // seconds
        difficulty: 1,
        notes: [
          { time: 0, lane: "left" },
          { time: 1, lane: "right" },
          { time: 2, lane: "left" },
          { time: 3, lane: "right" },
          { time: 4, lane: "left" },
          { time: 5, lane: "right" },
          { time: 6, lane: "left" },
        ],
      };

      const lanes = { left: 100, right: 300 };
      const keyBindings = { a: "left", l: "right" };

      const NOTE_SPEED = 200; // px per second
      const HIT_WINDOW = 40; // px around target line
      const TARGET_Y = 550;
      let notes = [];
      let heldKeys = {};
      let score = 0;
      let startTime = null;

      function spawnNotes() {
        const offset = 60 / beatMap.bpm; // seconds per beat
        beatMap.notes.forEach((note) => {
          notes.push({
            lane: note.lane,
            spawnTime: note.time * offset,
            duration: note.duration || 0,
            held: false,
            hitStart: false,
            hitEnd: false,
          });
        });
      }

      function drawLane(x) {
        ctx.fillStyle = "#333";
        ctx.fillRect(x - 40, 0, 80, canvas.height);
        ctx.fillStyle = "#555";
        ctx.fillRect(x - 40, TARGET_Y - 5, 80, 10);
      }

      function drawNote(note, currentTime) {
        const elapsed = currentTime - note.spawnTime;
        const y = elapsed * NOTE_SPEED;

        if (note.duration > 0) {
          // Long note
          const endTime = note.spawnTime + note.duration;
          const endY = (currentTime - endTime) * NOTE_SPEED;

          ctx.fillStyle = "#6cf";
          ctx.fillRect(lanes[note.lane] - 20, y, 40, endY - y);
          ctx.fillStyle = "#0cf";
          ctx.beginPath();
          ctx.arc(lanes[note.lane], y, 20, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(lanes[note.lane], endY, 20, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // Tap note
          ctx.fillStyle = "#f66";
          ctx.beginPath();
          ctx.arc(lanes[note.lane], y, 20, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function update(currentTime) {
        const now = (currentTime - startTime) / 1000;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawLane(lanes.left);
        drawLane(lanes.right);

        notes.forEach((note) => {
          if (
            (now >= note.spawnTime - 1 && !note.hitEnd) ||
            note.duration === 0
          ) {
            drawNote(note, now);
          }

          // Tap note hit detection
          if (
            !note.hitStart &&
            note.duration === 0 &&
            Math.abs((now - note.spawnTime) * NOTE_SPEED - TARGET_Y) <
              HIT_WINDOW &&
            heldKeys[note.lane]
          ) {
            logHit({
              timestamp: now,
              noteTime: note.spawnTime,
              result: "perfect",
              hitOffset: now - note.spawnTime,
              noteSpeed: NOTE_SPEED,
              hitWindow: HIT_WINDOW,
              difficulty: beatMap.difficulty,
            });
            note.hitStart = true;
            score += 100;
            document.getElementById("score").textContent = `Score: ${score}`;
          }

          // Long note start hit detection
          if (
            note.duration > 0 &&
            !note.hitStart &&
            Math.abs((now - note.spawnTime) * NOTE_SPEED - TARGET_Y) <
              HIT_WINDOW &&
            heldKeys[note.lane]
          ) {
            note.hitStart = true;
          }

          // Missed start for tap notes
          if (
            !note.hitStart &&
            note.duration === 0 &&
            (now - note.spawnTime) * NOTE_SPEED > TARGET_Y + HIT_WINDOW
          ) {
            note.hitStart = true; // Mark as processed to avoid double counting
            logHit({
              timestamp: now,
              noteTime: note.spawnTime,
              result: "miss",
              hitOffset: NaN,
              noteSpeed: NOTE_SPEED,
              hitWindow: HIT_WINDOW,
              difficulty: beatMap.difficulty,
            });
          }

          // Missed start for long notes
          if (
            !note.hitStart &&
            note.duration > 0 &&
            (now - note.spawnTime) * NOTE_SPEED > TARGET_Y + HIT_WINDOW
          ) {
            note.hitStart = true; // mark processed
            logHit({
              timestamp: now,
              noteTime: note.spawnTime,
              result: "miss",
              hitOffset: NaN,
              noteSpeed: NOTE_SPEED,
              hitWindow: HIT_WINDOW,
              difficulty: beatMap.difficulty,
            });
          }

          // Long note hold check (early release or success)
          if (note.hitStart && !note.hitEnd && note.duration > 0) {
            const endTime = note.spawnTime + note.duration;

            // Early release (miss)
            if (now < endTime && !heldKeys[note.lane]) {
              note.hitEnd = true;
              logHit({
                timestamp: now,
                noteTime: note.spawnTime,
                result: "miss",
                hitOffset: NaN,
                noteSpeed: NOTE_SPEED,
                hitWindow: HIT_WINDOW,
                difficulty: beatMap.difficulty,
              });
            }

            // Successful hold till end
            if (now >= endTime && heldKeys[note.lane]) {
              note.hitEnd = true;
              score += 200; // Bonus for long note
              document.getElementById("score").textContent = `Score: ${score}`;
            }
          }
        });

        animationId = requestAnimationFrame(update);
      }

      document.addEventListener("keydown", (e) => {
        const lane = keyBindings[e.key.toLowerCase()];
        if (lane) {
          heldKeys[lane] = true;
        }
      });

      document.addEventListener("keyup", (e) => {
        const lane = keyBindings[e.key.toLowerCase()];
        if (lane) {
          heldKeys[lane] = false;
        }
      });

      let gameEnded = null;

      function saveLogToLocalStorage() {
        const logs = JSON.parse(localStorage.getItem("hitLogs") || "[]");

        const logData = {
          hitLog: hitLog,
          score: score,
          difficulty: beatMap.difficulty,
          timestamp: new Date().toISOString(),
        };

        logs.push(logData);
        localStorage.setItem("hitLogs", JSON.stringify(logs));
        console.log("Hit log saved to local storage.");
      }

      function startGame() {
        const history = getHistoricalMetrics();
        const adjustment = decideDifficultyAdjustment(
          history,
          beatMap.difficulty
        );
        const newDiff = adjustDifficulty(beatMap.difficulty, adjustment);
        beatMap.difficulty = newDiff.newDifficulty;

        gameEnded = false;

        setTimeout(() => {
          if (!gameEnded) {
            endGame();
          }
        }, beatMap.duration * 1000 + 1000);

        spawnNotes();
        startModel();
        startTime = performance.now();
        requestAnimationFrame(update);
      }

      function endGame() {
        gameEnded = true;
        stopModel();
        cancelAnimationFrame(animationId);
        saveLogToLocalStorage();
        const finalScore = document.createElement("div");
        finalScore.style.textAlign = "center";
        finalScore.style.fontSize = "28px";
        finalScore.style.marginTop = "20px";
        finalScore.innerHTML = `<strong>Game Over!</strong><br>Final Score: ${score}`;
        document.body.appendChild(finalScore);
      }

      /*
       * model
       */

      const modelInterval = 500; // milliseconds

      let modelId = null;

      function startModel() {
        if (modelId) {
          clearInterval(modelId);
        }
        modelId = setInterval(() => {
          const currentTime = performance.now();
          const noteTime = currentTime - startTime;
          const result = "perfect"; // Simulate a perfect hit
          const noteSpeed = NOTE_SPEED;
          const hitWindow = HIT_WINDOW;
          const difficulty = beatMap.difficulty;

          const metrics = aggregatePerformance(hitLog);
          drawStatuses(metrics, gameEnded);
          const adjustment = decideDifficultyAdjustment(
            metrics,
            beatMap.difficulty
          );
          const newDifficulty = adjustDifficulty(
            beatMap.difficulty,
            adjustment
          );

          beatMap.difficulty = newDifficulty.newDifficulty;
        }, modelInterval);
      }

      function stopModel() {
        if (modelId) {
          clearInterval(modelId);
          modelId = null;
        }
      }

      const hitLog = [];

      function logHit({
        timestamp,
        noteTime,
        result,
        noteSpeed,
        hitWindow,
        difficulty,
      }) {
        const hitOffset = timestamp - noteTime;
        hitLog.push({
          timestamp,
          noteTime,
          result,
          hitOffset,
          noteSpeed,
          hitWindow,
          difficulty,
        });
      }
      function aggregatePerformance(logs) {
        const results = { perfect: 0, good: 0, bad: 0, miss: 0 };

        logs.forEach((entry) => {
          results[entry.result] = (results[entry.result] || 0) + 1;
        });

        const totalNotes = logs.length;
        const totalHits = totalNotes - results.miss;

        const hitAccuracy = (totalHits / totalNotes) * 100;

        const hitOffsets = logs
          .filter((entry) => entry.result !== "miss")
          .map((entry) => entry.hitOffset);

        const avgOffset =
          hitOffsets.reduce((a, b) => a + Math.abs(b), 0) / hitOffsets.length ||
          0;

        const stdDevOffset =
          Math.sqrt(
            hitOffsets.reduce(
              (sum, val) => sum + Math.pow(val - avgOffset, 2),
              0
            ) / hitOffsets.length
          ) || 0;

        const avgResultScore =
          (results.perfect * 1 + results.good * 0.75 + results.bad * 0.5) /
          (totalNotes || 1);

        return {
          hit_accuracy: hitAccuracy, // <- real metric here
          miss_rate: results.miss / totalNotes,
          unstable_rate: stdDevOffset,
          combo_length: calculateMaxCombo(logs),
          avg_result: avgResultScore,
        };
      }

      function weightedAveragePerformance(
        metrics,
        history,
        weightCurrent = 0.7
      ) {
        const w = weightCurrent;
        return {
          hit_accuracy:
            w * metrics.hit_accuracy + (1 - w) * history.hit_accuracy,
          miss_rate: w * metrics.miss_rate + (1 - w) * history.miss_rate,
          unstable_rate:
            w * metrics.unstable_rate + (1 - w) * history.unstable_rate,
          avg_result: w * metrics.avg_result + (1 - w) * history.avg_result,
          combo_length:
            w * metrics.combo_length + (1 - w) * history.combo_length,
        };
      }

      function calculateMaxCombo(logs) {
        let maxCombo = 0,
          combo = 0;
        for (const hit of logs) {
          if (hit.result !== "miss") combo++;
          else {
            maxCombo = Math.max(maxCombo, combo);
            combo = 0;
          }
        }
        return Math.max(maxCombo, combo);
      }

      function decideDifficultyAdjustment(currentMetrics, currentDifficulty) {
        const historicalMetrics = getHistoricalMetrics();
        const metrics = weightedAveragePerformance(
          currentMetrics,
          historicalMetrics
        );

        if (metrics.miss_rate > 0.2 || metrics.avg_result < 0.6) return -1; // Too hard
        if (
          metrics.miss_rate < 0.05 &&
          metrics.hit_accuracy > 95 &&
          metrics.unstable_rate < 20
        )
          return +1; // Too easy

        return 0; // No change
      }

      function adjustDifficulty(currentDifficulty, adjustment) {
        let newDifficulty = currentDifficulty + adjustment;
        newDifficulty = Math.max(1, Math.min(10, newDifficulty));

        // Optionally adjust other parameters:
        const noteSpeed = 1 + (newDifficulty - 5) * 0.1;
        const hitWindow = 50 - (newDifficulty - 5) * 2;

        return {
          newDifficulty,
          noteSpeed: parseFloat(noteSpeed.toFixed(2)),
          hitWindow: Math.max(20, hitWindow),
        };
      }

      function getHistoricalMetrics() {
        const logs = JSON.parse(localStorage.getItem("hitLogs") || "[]");
        const allHits = [];

        logs.forEach((logData) => {
          if (Array.isArray(logData.hitLog)) {
            allHits.push(...logData.hitLog);
          }
        });

        return aggregatePerformance(allHits);
      }

      function drawStatuses(metrics, gameEnded) {
        document.getElementById(
          "difficulty"
        ).textContent = `Difficulty: ${beatMap.difficulty}`;
        document.getElementById(
          "hitAccuracy"
        ).textContent = `Hit Accuracy: ${metrics.hit_accuracy.toFixed(2)}%`;
        document.getElementById("missRate").textContent = `Miss Rate: ${(
          metrics.miss_rate * 100
        ).toFixed(2)}%`;

        document.getElementById(
          "unstableRate"
        ).textContent = `Unstable Rate: ${metrics.unstable_rate.toFixed(2)}`;

        document.getElementById(
          "comboLength"
        ).textContent = `Max Combo: ${metrics.combo_length}`;
        document.getElementById(
          "avgResult"
        ).textContent = `Average Result: ${metrics.avg_result.toFixed(2)}`;

        document.getElementById(
          "gameEnded"
        ).textContent = `Game Ended: ${gameEnded}`;
        const hitLogDiv = document.getElementById("hitLog");
        hitLogDiv.innerHTML = "Hit Log:<br>";
        hitLog.forEach((hit) => {
          hitLogDiv.innerHTML += `Time: ${hit.timestamp.toFixed(2)}s, Result: ${
            hit.result
          }, Offset: ${hit.hitOffset.toFixed(2)}ms<br>`;
        });
      }

      startGame();
    </script>
  </body>
</html>
