<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Relative Challenge</title>
    <style>
      body {
        margin: 0;
        background: #111;
        color: #fff;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        font-size: 16px;
      }
      canvas {
        display: block;
        background: #222;
        border-radius: 8px;
        border: 1px solid #333;
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas" width="400" height="600"></canvas>
      <div id="uiContainer">
        <div class="statsColumn">
          <div id="scoreDisplay" class="statItem">
            Score: <strong>0</strong>
          </div>
          <div id="comboDisplay" class="statItem">
            Combo: <strong>0</strong>
          </div>
          <div id="maxComboDisplay" class="statItem">
            Max Combo: <strong>0</strong>
          </div>
        </div>
        <div class="statsColumn">
          <div id="difficultyDisplay" class="statItem">
            Difficulty: <strong>Medium</strong>
          </div>
          <div id="accuracyDisplay" class="statItem">
            Accuracy: <strong>100%</strong>
          </div>
          <div id="missRateDisplay" class="statItem">
            Miss Rate: <strong>0%</strong>
          </div>
        </div>
      </div>
      <div id="actionPanel">
        <button id="startButton">Start Game</button>
        <button id="stopButton" disabled>Stop Game</button>
      </div>
    </div>
    <div id="difficultyMessage"></div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // --- Game Configuration ---
      const LANES = { left: 100, right: 300 };
      const KEY_BINDINGS = { a: "left", l: "right" }; // Lowercase
      const TARGET_Y = 550; // Y-coordinate of the target line
      const NOTE_RADIUS = 20;
      const DIFFICULTY_CHECK_INTERVAL = 5000; // ms (check every 5 seconds)
      const DIFFICULTY_ADJUST_COOLDOWN = 15000; // ms (15 seconds)
      const RECENT_HITS_WINDOW = 30; // Number of recent hits to consider for adjustment

      const DIFFICULTIES = {
        easy: {
          name: "Easy",
          bpm: 90,
          noteSpeed: 120, // px/s
          hitWindowMillis: { perfect: 100, good: 150, missAfter: 200 },
          notes: generateSimpleBeatmap(90, 20, [
            "left",
            "right",
            "left",
            "left",
            "right",
          ]), // BPM, num_notes, pattern
          increaseTo: "medium",
          decreaseTo: null,
          performanceThresholds: {
            // To increase from easy
            minAccuracy: 0.8,
            maxMissRate: 0.1,
            minPerfectRate: 0.5,
          },
        },
        medium: {
          name: "Medium",
          bpm: 120,
          noteSpeed: 180,
          hitWindowMillis: { perfect: 100, good: 120, missAfter: 135 },
          notes: generateSimpleBeatmap(120, 30, [
            "left",
            "right",
            "left",
            "right",
            "left",
            "left",
            "right",
            "right",
          ]),
          increaseTo: "hard",
          decreaseTo: "easy",
          performanceThresholds: {
            // To increase from medium
            minAccuracy: 0.85,
            maxMissRate: 0.15,
            minPerfectRate: 0.4,
          },
          downgradeThresholds: {
            // To decrease from medium
            maxAccuracy: 0.7,
            minMissRate: 0.3,
          },
        },
        hard: {
          name: "Hard",
          bpm: 150,
          noteSpeed: 240,
          hitWindowMillis: { perfect: 30, good: 60, missAfter: 100 },
          notes: generateSimpleBeatmap(150, 40, [
            "left",
            "right",
            "left",
            "right",
            "left",
            "right",
            "left",
            "right",
            "left",
            "left",
            "right",
            "right",
          ]),
          increaseTo: null,
          decreaseTo: "medium",
          performanceThresholds: {}, // No increase from hard
          downgradeThresholds: {
            // To decrease from hard
            maxAccuracy: 0.65,
            minMissRate: 0.35,
          },
        },
      };

      // --- Game State ---
      let score = 0;
      let currentCombo = 0;
      let maxCombo = 0;
      let notesOnScreen = []; // Stores active note objects
      let hitLog = []; // { timestamp, result ('perfect', 'good', 'miss'), hitOffsetMs, difficulty }

      let currentDifficultyKey = "medium";
      let activeDifficulty = DIFFICULTIES[currentDifficultyKey];

      let gameRunningId = null;
      let difficultyCheckIntervalId = null;
      let currentMapStartTime = 0;
      let noteSpawnIndex = 0; // Index for activeDifficulty.notes
      let lastDifficultyChangeTime = 0;
      let gameStartTime = 0; // Overall game start time

      // --- UI Elements ---
      const scoreDisplay = document.getElementById("scoreDisplay");
      const comboDisplay = document.getElementById("comboDisplay");
      const maxComboDisplay = document.getElementById("maxComboDisplay");
      const difficultyDisplay = document.getElementById("difficultyDisplay");
      const accuracyDisplay = document.getElementById("accuracyDisplay");
      const missRateDisplay = document.getElementById("missRateDisplay");
      const difficultyMessage = document.getElementById("difficultyMessage");
      const startButton = document.getElementById("startButton");
      const stopButton = document.getElementById("stopButton");

      // --- Helper Functions ---
      function generateSimpleBeatmap(bpm, numNotes, pattern) {
        const notes = [];
        const beatInterval = 60 / bpm; // seconds per beat
        for (let i = 0; i < numNotes; i++) {
          notes.push({
            time: i * beatInterval * (Math.random() * 0.5 + 0.75), // time from map start in seconds, with some variation
            lane: pattern[i % pattern.length],
          });
        }
        return notes;
      }

      function showDifficultyMessage(message) {
        difficultyMessage.textContent = message;
        difficultyMessage.style.opacity = "1";
        setTimeout(() => {
          difficultyMessage.style.opacity = "0";
        }, 3000);
      }

      // --- Game Logic ---
      function loadBeatmap(difficultyKey) {
        if (!DIFFICULTIES[difficultyKey]) {
          console.error("Invalid difficulty key:", difficultyKey);
          return;
        }
        const oldDifficultyName = activeDifficulty.name;
        currentDifficultyKey = difficultyKey;
        activeDifficulty = DIFFICULTIES[currentDifficultyKey];

        notesOnScreen = [];
        currentMapStartTime = performance.now();
        noteSpawnIndex = 0;

        difficultyDisplay.innerHTML = `Difficulty: <strong>${activeDifficulty.name}</strong>`;
        if (gameRunningId && oldDifficultyName !== activeDifficulty.name) {
          // Avoid message on initial load if game already running
          showDifficultyMessage(
            `Difficulty changed to ${activeDifficulty.name}!`
          );
        }
        console.log(
          `Beatmap loaded for ${activeDifficulty.name}. Note speed: ${activeDifficulty.noteSpeed}, BPM: ${activeDifficulty.bpm}`
        );
      }

      function spawnNotes() {
        const mapElapsedTimeSec =
          (performance.now() - currentMapStartTime) / 1000;

        while (
          noteSpawnIndex < activeDifficulty.notes.length &&
          activeDifficulty.notes[noteSpawnIndex].time <=
            mapElapsedTimeSec +
              (canvas.height / activeDifficulty.noteSpeed) * 1.2
        ) {
          // Spawn if note start time is within a bit more than screen travel time
          const noteData = activeDifficulty.notes[noteSpawnIndex];

          // timeToReachTarget: time in seconds for a note to travel from y=0 to TARGET_Y
          const timeToReachTarget = TARGET_Y / activeDifficulty.noteSpeed;

          // idealHitTimeFromMapStartSec: when the note should be hit, relative to currentMapStartTime
          const idealHitTimeFromMapStartSec = noteData.time + timeToReachTarget;

          notesOnScreen.push({
            id: Date.now() + Math.random(), // Unique ID
            lane: noteData.lane,
            // startTimeInMapSecs: when the note starts falling from y=0, relative to currentMapStartTime
            startTimeInMapSecs: noteData.time,
            // idealHitTimeAbsoluteMs: absolute timestamp when note should be hit at TARGET_Y
            idealHitTimeAbsoluteMs:
              currentMapStartTime + idealHitTimeFromMapStartSec * 1000,
            hit: false,
            color: "#f66", // Default color
          });
          noteSpawnIndex++;
        }
      }

      function updateUI() {
        scoreDisplay.innerHTML = `Score: <strong>${score}</strong>`;
        comboDisplay.innerHTML = `Combo: <strong>${currentCombo}</strong>`;
        maxComboDisplay.innerHTML = `Max Combo: <strong>${maxCombo}</strong>`;

        const recentLog = hitLog.slice(-RECENT_HITS_WINDOW); // Use recent window for display
        const stats = aggregatePerformance(recentLog);
        accuracyDisplay.innerHTML = `Accuracy: <strong>${stats.accuracy.toFixed(
          1
        )}%</strong>`;
        missRateDisplay.innerHTML = `Miss Rate: <strong>${stats.missRate.toFixed(
          1
        )}%</strong>`;
      }

      function drawLanes() {
        for (const laneKey in LANES) {
          const x = LANES[laneKey];
          // Lane line
          ctx.fillStyle = "#333";
          ctx.fillRect(x - 30, 0, 60, canvas.height);
          // Target line segment
          ctx.fillStyle = "#555";
          ctx.fillRect(
            x - NOTE_RADIUS - 5,
            TARGET_Y - 5,
            (NOTE_RADIUS + 5) * 2,
            10
          );
          // Key hint
          ctx.fillStyle = "#777";
          ctx.font = "16px Arial";
          ctx.textAlign = "center";
          const boundKey = Object.keys(KEY_BINDINGS).find(
            (key) => KEY_BINDINGS[key] === laneKey
          );
          if (boundKey) {
            ctx.fillText(boundKey.toUpperCase(), x, TARGET_Y + 30);
          }
        }
      }

      function drawNote(note) {
        const mapElapsedTimeSec =
          (performance.now() - currentMapStartTime) / 1000;
        // noteY is current position of the note's center
        const noteY =
          (mapElapsedTimeSec - note.startTimeInMapSecs) *
          activeDifficulty.noteSpeed;

        if (noteY > canvas.height + NOTE_RADIUS) {
          // Note is off-screen (bottom)
          if (!note.hit) {
            // Missed
            currentCombo = 0;
            logHitData({
              result: "miss",
              hitOffsetMs: NaN,
              difficulty: currentDifficultyKey,
            });
            note.hit = true; // Mark as processed
          }
          return false; // Indicate note should be removed
        }

        if (noteY < -NOTE_RADIUS) return true; // Not yet on screen fully

        ctx.beginPath();
        ctx.arc(LANES[note.lane], noteY, NOTE_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = note.hit
          ? note.color === "#6f6"
            ? "#383"
            : "#833"
          : note.color; // Darker if hit
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.stroke();
        return true; // Indicate note is still active
      }

      function gameLoop(timestamp) {
        if (!gameRunningId) return;
        gameStartTime = gameStartTime || timestamp; // Initialize overall game start time

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawLanes();
        spawnNotes();

        notesOnScreen = notesOnScreen.filter((note) => {
          if (
            note.hit &&
            performance.now() - note.idealHitTimeAbsoluteMs > 500
          ) {
            // Remove hit notes after a delay
            return false;
          }
          return drawNote(note);
        });

        updateUI();
        gameRunningId = requestAnimationFrame(gameLoop);
      }

      function handleKeyPress(event) {
        if (!gameRunningId) return;
        const key = event.key.toLowerCase();
        const laneHit = KEY_BINDINGS[key];

        if (laneHit) {
          const playerActionTimeMs = performance.now();
          let bestNote = null;
          let minTimeDiffToTarget = Infinity;

          // Find the closest active note in the correct lane
          for (const note of notesOnScreen) {
            if (!note.hit && note.lane === laneHit) {
              const timeDiffToTarget = Math.abs(
                playerActionTimeMs - note.idealHitTimeAbsoluteMs
              );
              // Check if note is visually near target
              const mapElapsedTimeSec =
                (playerActionTimeMs - currentMapStartTime) / 1000;
              const noteY =
                (mapElapsedTimeSec - note.startTimeInMapSecs) *
                activeDifficulty.noteSpeed;
              if (
                Math.abs(noteY - TARGET_Y) <
                activeDifficulty.noteSpeed * 0.5
              ) {
                // Within 0.5s of travel from target
                if (timeDiffToTarget < minTimeDiffToTarget) {
                  minTimeDiffToTarget = timeDiffToTarget;
                  bestNote = note;
                }
              }
            }
          }

          if (bestNote) {
            const hitOffsetMs =
              playerActionTimeMs - bestNote.idealHitTimeAbsoluteMs;
            const absHitOffsetMs = Math.abs(hitOffsetMs);
            let result = "miss"; // Default to miss

            if (absHitOffsetMs <= activeDifficulty.hitWindowMillis.perfect) {
              result = "perfect";
              score += 100;
              bestNote.color = "#6f6"; // Green for perfect
            } else if (
              absHitOffsetMs <= activeDifficulty.hitWindowMillis.good
            ) {
              result = "good";
              score += 50;
              bestNote.color = "#ff6"; // Yellow for good
            }
            // Misses are also handled if player hits too early/late outside 'good' window,
            // or if note passes TARGET_Y + missAfter window.

            if (result !== "miss") {
              currentCombo++;
              if (currentCombo > maxCombo) {
                maxCombo = currentCombo;
              }
            } else {
              currentCombo = 0;
            }

            bestNote.hit = true;
            logHitData({
              result,
              hitOffsetMs,
              difficulty: currentDifficultyKey,
            });
          }
        }
      }

      function logHitData(data) {
        data.timestamp = performance.now();
        hitLog.push(data);
        // Keep hitLog from growing excessively, e.g., last 200 entries
        if (hitLog.length > 200) {
          hitLog.shift();
        }
      }

      function aggregatePerformance(logEntries) {
        if (logEntries.length === 0) {
          return {
            accuracy: 100,
            missRate: 0,
            perfectRate: 0,
            goodRate: 0,
            currentMaxCombo: 0,
            avgHitOffset: 0,
            unstableRate: 0,
          };
        }

        let perfects = 0;
        let goods = 0;
        let misses = 0;
        let currentComboCalc = 0;
        let maxComboCalc = 0;
        const validHitOffsets = [];

        logEntries.forEach((entry) => {
          if (entry.result === "perfect") {
            perfects++;
            currentComboCalc++;
            if (entry.hitOffsetMs !== undefined && !isNaN(entry.hitOffsetMs))
              validHitOffsets.push(entry.hitOffsetMs);
          } else if (entry.result === "good") {
            goods++;
            currentComboCalc++;
            if (entry.hitOffsetMs !== undefined && !isNaN(entry.hitOffsetMs))
              validHitOffsets.push(entry.hitOffsetMs);
          } else {
            // miss
            misses++;
            if (currentComboCalc > maxComboCalc)
              maxComboCalc = currentComboCalc;
            currentComboCalc = 0;
          }
        });
        if (currentComboCalc > maxComboCalc) maxComboCalc = currentComboCalc;

        const totalJudged = perfects + goods + misses;
        const totalHits = perfects + goods;

        const accuracy =
          totalJudged > 0 ? (totalHits / totalJudged) * 100 : 100;
        const missRate = totalJudged > 0 ? (misses / totalJudged) * 100 : 0;
        const perfectRate = totalHits > 0 ? (perfects / totalHits) * 100 : 0; // Perfects out of HITS
        const goodRate = totalHits > 0 ? (goods / totalHits) * 100 : 0; // Goods out of HITS

        let avgHitOffset = 0;
        let unstableRate = 0; // Standard deviation of hit offsets
        if (validHitOffsets.length > 0) {
          avgHitOffset =
            validHitOffsets.reduce((sum, val) => sum + val, 0) /
            validHitOffsets.length;
          const variance =
            validHitOffsets.reduce(
              (sum, val) => sum + Math.pow(val - avgHitOffset, 2),
              0
            ) / validHitOffsets.length;
          unstableRate = Math.sqrt(variance);
        }

        return {
          accuracy,
          missRate,
          perfectRate, // Percentage of HITS that were perfect
          goodRate, // Percentage of HITS that were good
          currentMaxCombo: maxComboCalc,
          avgHitOffset,
          unstableRate,
          totalJudged,
        };
      }

      function checkDifficultyAdjustment() {
        if (
          performance.now() - lastDifficultyChangeTime <
          DIFFICULTY_ADJUST_COOLDOWN
        ) {
          return; // Cooldown active
        }

        const recentLog = hitLog.slice(-RECENT_HITS_WINDOW);
        if (recentLog.length < RECENT_HITS_WINDOW / 2) {
          // Need enough data
          return;
        }

        const perf = aggregatePerformance(recentLog);
        console.log(
          `Perf Check (${activeDifficulty.name}): Acc ${perf.accuracy.toFixed(
            1
          )}%, Miss ${perf.missRate.toFixed(
            1
          )}%, PerfRate ${perf.perfectRate.toFixed(1)}% (of hits)`
        );

        const currentPerfThresholds = activeDifficulty.performanceThresholds;
        const currentDowngradeThresholds = activeDifficulty.downgradeThresholds;

        // Try to increase difficulty
        if (activeDifficulty.increaseTo && currentPerfThresholds) {
          if (perf.accuracy >= currentPerfThresholds.minAccuracy) {
            changeDifficulty(activeDifficulty.increaseTo);
            return;
          }
        }

        // Try to decrease difficulty
        if (activeDifficulty.decreaseTo && currentDowngradeThresholds) {
          if (perf.accuracy < currentDowngradeThresholds.maxAccuracy) {
            changeDifficulty(activeDifficulty.decreaseTo);
            return;
          }
        }
      }

      function changeDifficulty(newDifficultyKey) {
        if (newDifficultyKey && newDifficultyKey !== currentDifficultyKey) {
          console.log(
            `Attempting to change difficulty from ${currentDifficultyKey} to ${newDifficultyKey}`
          );
          loadBeatmap(newDifficultyKey);
          lastDifficultyChangeTime = performance.now();
          // Optional: Clear a portion of hitLog or adjust how aggregatePerformance weights recent data
          // For now, the sliding window of RECENT_HITS_WINDOW in checkDifficultyAdjustment handles this.
        }
      }

      function startGame() {
        score = 0;
        currentCombo = 0;
        maxCombo = 0;
        hitLog = [];

        // Initial difficulty can be set here or default to 'medium'
        // currentDifficultyKey = 'medium'; // Or load from historical data if implemented
        loadBeatmap(currentDifficultyKey); // Load initial/current beatmap

        lastDifficultyChangeTime = performance.now(); // Start cooldown timer
        gameStartTime = performance.now();

        if (gameRunningId) cancelAnimationFrame(gameRunningId);
        gameRunningId = requestAnimationFrame(gameLoop);

        if (difficultyCheckIntervalId) clearInterval(difficultyCheckIntervalId);
        difficultyCheckIntervalId = setInterval(
          checkDifficultyAdjustment,
          DIFFICULTY_CHECK_INTERVAL
        );

        startButton.disabled = true;
        stopButton.disabled = false;
        console.log("Game started.");
      }

      function stopGame() {
        if (gameRunningId) {
          cancelAnimationFrame(gameRunningId);
          gameRunningId = null;
        }
        if (difficultyCheckIntervalId) {
          clearInterval(difficultyCheckIntervalId);
          difficultyCheckIntervalId = null;
        }
        startButton.disabled = false;
        stopButton.disabled = true;
        showDifficultyMessage("Game Stopped. Final Score: " + score);
        console.log("Game stopped.");
      }

      // --- Event Listeners ---
      document.addEventListener("keydown", handleKeyPress);
      startButton.addEventListener("click", startGame);
      stopButton.addEventListener("click", stopGame);

      // --- Initial Setup ---
      loadBeatmap(currentDifficultyKey); // Load initial beatmap config but don't start game
      updateUI(); // Show initial UI state
      console.log("Game ready. Press Start.");
    </script>
  </body>
</html>
